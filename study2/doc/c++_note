命令行执行编译c++文件: g++ -o hello hello.cpp/g++ hello.cpp -o hello; 会得到一个hello.out文件,
	如果不指定hello文件名，则默认会命名为a.out;
命令行执行c++程序 ./hello; 会执行上一步的到的hello文件

输出
cout << "hello" << endl;

其中<<左侧是一个输出流,将右边的表达式计算然后赋值给左侧的输出流cout;
等价于 (cout << "hello" << endl);

输入与输出类似;

endl叫做操纵符,表示结束当前行,并将与设备关联的缓冲区中的内容刷到设备中;

关键字:cout 输出;cin 输入;endl 结束; :: 作用域运算符

标准库头文件一半不带后缀!!!


c++的类型有有符号型和无符号型,对应的类型前加unsigned就成了无符号型,无符号型所有位都用来
存放数据,有符号型最高位用来存放符号

类型的转换:
1 非布尔->布尔:0 false; 其他 true
2 布尔  ->非布尔: true:1; false:0
3 无符号数赋予一个大于它范围的数:对表示的最大数取模后的余数
4 带符号数赋予一个大于它范围的数:变为undefined

注释型代,0就等价于注视,1就等价于if(true){do something}
#if 1/0 
#endif

typedef int newtype;//给int起另外一个名字newtype; newtype a;//a为int类型
c++中的枚举:
enum 枚举名{
	标识符[=int],
	标识符[=int],
	......
	标识符[=int]
} 枚举变量;
可以省掉[=int],此时会赋默认值,从0开始,并且后面都比前面的大1;
eg: enum color {red, green=5,blue}; //red = 0,blue=6;
color = blue//color = 6;

float :32位，依次为:1位符号位 8位指数位 23位数字位
double:64位，依次为:1位符号位 11位指数位 52位小数位
extern关键字:表示变量或者函数定义在别的文件中,提示编译器去别的文件中寻找

c++声明和定义的区别：
1 定义是声明，声明不是定义l;声明只是指明类型和名字，不会分配存储空间，定义会;
2 带有extern关键字的是声明，不带的是定义，如果extern的同时初始化了，就是定义
eg: extern int a;//声明
	extern int a = 10;//定义
	int a;//定义
	int a = 10;//定义
3 函数的声明和定义:有函数体的是定义，否则就是声明

c++中常量的定义
1 #define A = 10;//宏定义:编译时概念,不会分配内存,无论在哪定义,都视为全局的,能通过#undef取消,
	不能用作参数
2 const A = 10;//一般定义:运行时概念,会分配内存,一般定义域,不能取消,可以用作参数

c++存储类:
	1 register:表明可能存储在寄存器中(最大尺寸等于寄存器的大小),
		能快速读取,不能进行&运算,因为没有内存位置;
	2 thread_local:仅可在创建它的线程中访问,在线程创建时创建,在线程销毁时销毁

c++函数:
参数传递:1 传值 修改形参不会影响实参
		 2 指针 修改形参会影响实参
		 3 引用 修改形参会影响实参
		 4 可以使用参数默认值
Lambda表达式:可以作为参数使用,类似于groovy中的closure;
[](parameters)->returntype{body};如果返回值为void,则可以省略;[]内可以放置的内容如下:

[]      // 沒有定义任何变量。使用未定义变量会引发错误。
[x, &y] // x以传值方式传入（默认），y以引用方式传入。
[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。

eg:(需code)
// [](int x,int y)->{return x+y}; [](intx)->int {return x*x};


数学运算:
1 数学运算头文件:cmath
2 获取时间相关的头文件:ctime
3 随机数相关的头文件:cstdlib;随机数要先使用srand()设置种子才有效,然后使用rand()获取随机数

setw(int n)打印n个空格,可以用来格式化输出
c++字符串实际就是以null('\0')结尾的一维字符数组,可以这样定义:char str[] = "hello";
c++字符串的操作头文件:cstring
c++字符串类型string头文件:string

c++取地址运算符:&
指针的声明或定义使用*号,指针存放的是它指向的变量内存地址,指针的类型必须和它指向的内存地址的
	变量的类型一样; 
	eg: int a = 10; int *b = &a(b是int型的,a也必须是int型);//b是a的地址,*b是a的值
c++指针可进行++、--、+、-运算,可以定义指向指针的指针
&:取址
*:取值

&(引用):int& r = i;int i = 3; r就是3,但是r不会分配内存空间;
 引用必须在声明时初始化,等价于常量,一旦指定就会绑定到指向的变量(随变量的改变而改变),不能更改
 eg: int& r  = i;int i = 10; int j = i;//r与i内存地址相同,j会另外开辟一个内存空间

c++数据结构:
1 struct structtype_name{
	type1 name;
	type2 name;
}object_name

指向结构的指针
struct User *userPointer;
通过指针访问成员,需要使用->运算符而不是.运算符
eg: User user;user.name;
	User *userPointer = &user; userPointer->name;
使用typedef关键字给结构起名,使其像class一样使用

2 class
	构造函数:创建对象时调用
	析构函数:删除对象时调用
	拷贝构造函数:创建对象时使用之前创建过的对象来初始化新的对象
	友元函数:可以访问类的private和protected成员
	内联函数:通过它编译器可以在调用函数的地方扩展函数体中的代码
	指向对象的指针:类似于指向结构体的指针
class 不能作为函数参数

class和struct的区别:class的成员默认是private的,struct的成员默认是public的
class的继承: class A: public B{}; A继承了B,多继承使用,隔开
c++中的this是一个指针,使用它访问成员需要使用->而不是.;
c++虚拟继承
c++函数重载和运算符重载
c++多态:跟java异曲同工
c++虚函数:virtual,纯虚函数 virtual int func() = 0;//没有函数体, 类似于java的抽象函数
c++数据抽象与数据封装:类似于java中的setter,getter思想
c++接口(抽象类):如果一了类中至少有一个纯虚函数,则这个类就是抽象类或接口

















