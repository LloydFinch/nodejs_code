<html>

<head>
	<meta charset = utf-8>
	<title>jvm笔记</title>
</head>

<body>

<pre>
1  程序计数器：唯一一个不会报OOM的区域，线程私有的，指示当前线程所执行的字节码的行号指示器

2 虚拟机栈：线程私有，成员为一个个的栈帧，栈帧存放：局部变量表、操作数栈、动态链接、方法出口等信息，方法的调用，就表示为栈帧的入栈出栈的过程，一般说的栈指的是局部变量表

3 本地方法栈：跟虚拟机栈类似。区别：虚拟机栈为java字节码服务，本地方法栈为native方法服务

4 堆：进程级，所有线程共享，存放所有对象和数组，GC重点关照的对象

5 方法区：进程级，所有线程共享，存放已被JVM加载的类信息、常量、静态变量等

6 运行时常量池：方法区的一部分，用于存放Class文件中的编译期生成的字面量和符号引用

7 直接内存：不属于Java运行时数据区域的一部分，但是也会报OOM异常

8 JVM创建对象的过程(JVM角度)：遇到new指令 -> 检查指令参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化过 -> 没有就进行相应的加载过程，有就直接使用

9 对象在内存中的存储布局：对象头，实例数据，数据填充

10 JVM的分配策略：相同宽度的数据被分到一起，父类变量的分配在子类之前

11 JVM要求对象的大小必须是8字节的整数倍，不满足时由对齐填充来补全

12 对象访问方式：句柄访问：指针指向句柄，句柄指向对象实例数据和对象类型数据
			优点：因为句柄在在堆中，对象改变不需要改变指针，只要改变句柄
          就可以
缺点：访问慢，多了一次指针定位的操作
		       指针访问：指针直接指向实例对象实例数据和对象类型数据
			优点：访问快
			缺点：对象移动，指针也要移动
13 内存溢出相关：
	堆溢出：泄漏还是溢出，泄漏就断开引用链，溢出看是否能调整JVM分配的大小
	栈溢出：每个线程分配的内存越大，越容易溢出，因为这样可建立的线程就减少
		   分配新线程的时候由于申请不到足够的内存，就出现溢出

14 程序计数器，本地方法栈，虚拟机栈所占用的内存是在编译器可知的，所以一般不会发生OOM问题，而堆所占用的内存是动态分配的，只有在运行期才知道，所以是GC的重点关注对象

15 对象存活判定策略
(1) 引用计数算法：给对象添加一个引用计数器，有引用就+1，引用失效就-1，
当为0的时候，表明对象不再被使用，可以回收；优点：实现简单，效率高；
缺点：无法解决对象互相循环引用的问题
(2) 可达性算法(java使用的算法)：将对象作为一系列的节点，GCRoots作为根结点，如果从GCRoots到该节点不可达，则该节点以及该节点的自节点都可以被回收，在
java中，此算法不仅仅使用于堆，还应用在虚拟机栈，本地方法栈，方法区中的常量和静态属性
(3) 强引用：就是一般的对象声明，打死都不回收，除非已经都置为null(此时
        等价于弱引用)
      软引用：还有用但非必须，内存不足才回收，因为还有用，但是现在用不上
      弱引用：已经没用，看见就回收
      虚引用：no egg use

16 对象被回收之前会调用到finalize()方法里面，如果要拯救这个对象，只需要在这里重新
建立起引用链即可，每个对象的finalize方法只执行一次，此方法打死都不能用

17 方法区的回收，主要回收废弃常量和无用的类
回收常量：无引用就回收
回收类：    所有实例都已回收、ClassLoader已被回收、.Class没有引用(反射等)

18 垃圾收集算法：
标记-清除法：先标记出所有需要回收的对象，然后由GC统一回收，缺点：效率低、
	清除后产生的空白内存空间不连续，分配不了较大的对象
      (2) 复制算法：将内存分为相等的两块A、B，每次使用都放在A里面，A用完了就将A
复制到B里面，然后释放A，优点：内存是连续的，按顺序释放A即可，并且内存是
连续的；缺点：浪费了一半的内存，要进行复制操作，效率低；
优化：A、B不一定非要按照1:1分配，可以将A
设置的大一些，因为有用的对象比较少，所以B可以小一些
      (3) 标记-整理法：类似标记-清除法，先标记可以回收的对象，然后让不能回收的对象
	移动到一端，再清除除了这一端以外的所有对象
      (4)  分代算法：新生代：死的比较多，使用复制算法，A:B = 9:1，
		       老生代：存活的多，使用标记-整理法

19 GC一般都是在安全点触发，产生安全点的条件：指令复用，如方法调用，循环跳转，
异常跳转等

20 抢先式中断：GC发生时，中断所有线程，如果有线程不在安全点上，则恢复线程，让它
		跑到安全点上
     主动式中断：GC需要中断时，设置一个标志，各个线程执行时，去轮询这个标志，发现
		标志为真时，就中断挂起，轮询标志的地方：安全点，分配内存的地方

21  安全区域：引用不会发生变化的代码片，在这里GC都是安全的，线程这里离开时，
会检测一下根结点枚举是否进行完毕，完了就离开，否则需要等到收到可以安全离开
的信号才能离开

22 G1收集器思想：内存化整为零，
进行步骤：
初始标记：标记GC Root直接关联的对象，耗时较短
并发标记：对堆中的对象进行可达性分析，耗时较长，在用户线程中执行
最终标记：对并发标记阶段用于用户线程进行导致的标记变化作标记，需要停顿线程
	      但是可并行执行
筛选回收 ：对各个内存区的回收价值和成本进行排序，根据用户期望的GC时间指定
      回收计划 进行回收

23 对象优先在新年代的Eden区中分配内存，如果Eden区没有足够的内存， 则会发起一次
Minor GC 

24 JVM新生代和老年代的分配策略，新生对象在Eden区经过一次minor后，仍然存活并且
能够被survivor容纳，就被放进survivor中去，将年龄设为1，对象每熬过一次minor，就让
年龄增长一岁，当年龄增长到一定程度(默认是15岁)，就会被移动到老年代中去

25 如果在survivor空间中所有相同年龄的对象加起来大于此空间的一半，则大于或等于该年龄的对象就直接进入老年代

26 空间分配担保策略：每次minor GC之前，先检查一下老年代最大可用连续空间是否大于
新生代所有对象的总空间，如果大于，则此次minor GC是安全的，否则就检查一下老年代
最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于则进行此次
minor GC，即使是有风险的，否则就进行一次Full GC

27 Class文件的结构：以8位字节为单位的二进制流，中间没有分隔符空格等，都是有效
数据，当遇到需要占用8位字节以上的数据时，按照高位在前的原则进行分配，Class文件
采用一种类似于C语言结构体的伪结构体，只有无符号数(u开头:u2)和表(_info结尾:a_info)

28 每个Class文件开头的4个字节称为魔数(0xCAFEBABY)，它的唯一作用是确定这个
文件是否是一个能被虚拟机接受的Class文件，紧跟着的4个字节存放Class文件的版本号
5-6字节存放次版本号，7-8字节存放主版本号，版本号是从45开始的，紧接着是常量池
入口，常量池使用一个u2(无符号2字节)类型数据表示大小，表示常量的个数，下标从1开始，
下标0表示不引用常量池的任何一个常量，常量池中的每一个常量都是一个表，表开头的第一
位是一个u1类型的标志位，表示当前属于哪种常量，常量池结束之后，紧跟着的两个字节代表访问标志(类还是接口，是否是final或abstract，public还是private)，接着按顺序是：类
索引，父类索引，接口索引；字段表集合；方法表集合；属性表集合

30 JVM操作码长度只有一个字节

31 类的生命周期：加载、验证、准备、解析、初始化、使用、卸载；其中验证、准备、解析
是连接过程；加载、验证、准备、初始化、卸载顺序是固定的。

32 类立即加载：new的时候、访问或设置static属性的时候(final和默认值除外)、调用静态方法的时候；使用反射的时候，如果没有初始化，则先初始化；初始化类的时候，如果它的父类没有初始化，则先初始化父类；JVM启动时，需要一个执行的主类(包含main()方法的类)，先初始化这个类；被动引用不会触发初始化。接口的加载与类相似，但是接口初始化的时候不会
先初始化父类，只有其父类被用到的时候才初始化其父类。

33 加载：
(1) 通过类的全限定名获取类的二进制流字节数据
(2) 将二进制字节流保存的静态数据结构转换为方法区需要的运行时数据结构
(3) 使用运行时数据结构在内存中生成.Class文件，作为方法区此类的各种访问入口

34 验证：文件格式验证，元数据验证，字节码验证，符号引用验证

35 准备：为类变量(而不是实例变量)分配内存并赋初始值，这些变量的内存都在方法区中进行分配，注意是类变量(static修饰的)，而不是实例变量，初始值(一般为0)而不是默认值，除非是final修饰的，初始值才等于默认值

36 解析：将常量池中的符号引用替换为直接引用

37 初始化：执行类变量中所有的赋值动作和静态代码块，执行之前会先执行父类，所以
Object的<clinit>动作总是第一执行

38 栈帧：虚拟机栈的元素，包括：局部变量表、操作数栈、动态连接、方法返回地址等
一系列额外信息。
局部变量表：是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，
	          第一个一般放的是this
操作数栈：用于存放方法执行时，各种字节码的写入和提取，可以线程共享

39 对于抽象类静态分派可能产生的问题，应该使用抽象方法，达到动态分派

40 栈指令集：跨平台，但操作指令多，耗费内存
     寄存器指令集：操作指令简单，省内存，但不跨平台

41 jvm内存模型：
原子性
可见性：一个线程改变变量，其他线程都能立即知道。volatile、synchronized、final
有序性 

42 valatile特性：修饰的变量对所有线程可见，但是不能保证安全性；禁止指令重排序优化

43 java允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的读写操作 

44 线程内串行(有序性)，线程间并行(指令重排序，工作内存与主内存同步延迟)

45 先行发生原则，如果不满足此原则，则有指令重排的风险
java中满足先行发生原则的条件：
程序次序规则
管程锁定规则
volatile规则
线程启动规则
线程终止规则
线程中断规则
对象终结规则
传递性
不满足此条件的将有指令重排的风险，可以修改为满足此条件即可

46 线程安全相关：
	不可变
	绝对线程安全
	相对线程安全
	线程兼容
	线程对立

47 线程安全解决：
	互斥同步
	非阻塞同步
	





Tips:
1 return 语句指向一条字节码地址

2 32bit的数据类型占用一个局部变量空间，64bit的占用两个，一个内存地址占用一个局部变量空间

3 可以推测出局部变量表占用的内存大小在编译期间是完全确定的，当进入一个方法时，需要在栈中分配多大的内存是完全确定的

4 如果线程请求的栈深度大于虚拟机所允许的的深度，将抛出StackOverFlow异常(通常在非法的递归时发生)；如JVM可以动态扩展，扩展时无法申请到足够的内存，就会抛出OOM异常

5 类加载后Class文件保存的信息：类的版本，字段，方法，接口等描述信息，以及常量池

6 String.intern()是一个native方法，作用：如果字符串常量池(不是堆)已经有此字符串的实例，有就返回，没有就添加进去再返回

7 GC时一切工作都要停下来，等待GC完成后才能继续处理

8 复习一下汇编语言指令，JVM使用了它

9 吞吐量(面向JVM的定义)：运行用户代码的时间/(运行用户代码的时间+垃圾回收的时间)

10 Minor GC新生代GC，Major GC，老生代GC，通常Major GC会伴随着至少一起Minor GC
Major GC一般比Minor GC慢10倍以上

11 尽量避免写大对象，以及朝生夕灭的短命大对象，这会造成内存还有很大空间时就提前
触发GC来安置他们，有可能会将新生代大对象直接放进老生代空间中去，因为Eden区放不下
这么大的对象

12 静态代码块中只能访问定义在它之前的静态变量，不能访问定义在它之后的静态变量，
但是却可以给定义在它之后的静态变量赋值
</pre>
</body>

</html>
